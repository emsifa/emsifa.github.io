<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" class="h-full" data-vue-tag="lang,class">
  <head>
    <title data-vue-tag="true">Posts tagged &quot;RU201&quot;</title><meta data-vue-tag="true" charset="utf-8"><meta data-vue-tag="true" name="generator" content="Gridsome v0.6.7"><meta data-vue-tag="true" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="true" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="true" data-key="description" name="description" content="Browse posts tagged &quot;RU201&quot;"><meta data-vue-tag="true" property="og:type" content="website"><meta data-vue-tag="true" property="og:title" content="Posts tagged &quot;RU201&quot;"><meta data-vue-tag="true" property="og:description" content="Browse posts tagged &quot;RU201&quot;"><meta data-vue-tag="true" property="og:url" content="https://blog.emsifa.com//tag/RU201/"><meta data-vue-tag="true" property="og:image" content="https://blog.emsifa.com/images/bleda-card.png"><meta data-vue-tag="true" name="twitter:card" content="summary_large_image"><meta data-vue-tag="true" name="twitter:title" content="Posts tagged &quot;RU201&quot;"><meta data-vue-tag="true" name="twitter:description" content="Browse posts tagged &quot;RU201&quot;"><meta data-vue-tag="true" name="twitter:site" content="@cossssmin"><meta data-vue-tag="true" name="twitter:creator" content="@cossssmin"><meta data-vue-tag="true" name="twitter:image" content="https://blog.emsifa.com/images/bleda-card.png"><link data-vue-tag="true" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.efcb514.png"><link data-vue-tag="true" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.efcb514.png"><link data-vue-tag="true" rel="icon" type="image/png" sizes="96x96" href="/assets/static/favicon.b9532cc.efcb514.png"><link data-vue-tag="true" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/assets/static/favicon.f22e9f3.efcb514.png"><link data-vue-tag="true" rel="apple-touch-icon" type="image/png" sizes="152x152" href="/assets/static/favicon.62d22cb.efcb514.png"><link data-vue-tag="true" rel="apple-touch-icon" type="image/png" sizes="120x120" href="/assets/static/favicon.1539b60.efcb514.png"><link data-vue-tag="true" rel="apple-touch-icon" type="image/png" sizes="167x167" href="/assets/static/favicon.dc0cdc5.efcb514.png"><link data-vue-tag="true" rel="apple-touch-icon" type="image/png" sizes="180x180" href="/assets/static/favicon.7b22250.efcb514.png"><noscript data-vue-tag="true" ><style>.g-image--loading{display:none;}</style></noscript><link rel="preload" href="/assets/css/7.styles.a524cf9a.css" as="style"><link rel="preload" href="/assets/js/app.163b108a.js" as="script"><link rel="preload" href="/assets/js/page--src-templates-tag-vue.eeb0f532.js" as="script"><link rel="prefetch" href="/assets/js/9.ef6083f0.js"><link rel="prefetch" href="/assets/js/page--src-pages-404-vue.71a5a466.js"><link rel="prefetch" href="/assets/js/page--src-pages-index-vue.ce119b9f.js"><link rel="prefetch" href="/assets/js/page--src-templates-author-vue.1be59295.js"><link rel="prefetch" href="/assets/js/page--src-templates-post-vue.750647f8.js"><link rel="prefetch" href="/assets/js/vendors~page--src-pages-index-vue~page--src-templates-author-vue~page--src-templates-post-vue~page--~ed3ac5eb.0bdbde02.js"><link rel="prefetch" href="/assets/js/vendors~page--src-templates-post-vue.0f12d6b5.js"><link rel="stylesheet" href="/assets/css/7.styles.a524cf9a.css">
  </head>
  <body class="antialiased" data-vue-tag="class">
    <div data-server-rendered="true" id="app"><main><header><div class="max-w-xl md:max-w-3xl xl:max-w-4xl flex flex-col-reverse mx-auto text-center px-6 pt-24 pb-10 md:py-32 border-b border-gray-300"><p class="text-gray-700 leading-normal">1 posts in total</p><h1 class="text-4xl sm:text-5xl md:text-6xl font-sans font-bold mb-2 capitalize">RU201</h1><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" role="img" aria-labelledby="tagIcon" class="w-5 sm:w-6 fill-current text-gray-500 mx-auto mb-1"><title id="tagIcon">Posts tagged</title><path d="M0 10V2l2-2h8l10 10-10 10L0 10zm4.5-4a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z"></path></svg></div><nav class="absolute top-0 left-0 z-20 mt-6 ml-6"><a href="/" class="text-sm border text-gray-900 border-gray-400 opacity-75 hover:opacity-100 rounded-full px-4 py-2 transition-opacity active">← Home</a></nav></header><section><article><div class="mx-auto max-w-3xl px-6"><div class="py-8 sm:py-20 border-b border-gray-300"><header class="text-center mb-8"><time datetime="2019-08-15 10:00:00" class="text-gray-700 text-xs mb-2 uppercase">15 August, 2019</time><h2 class="text-3xl sm:text-4xl leading-tight font-sans mb-1 sm:mb-2"><a href="/redis-university-ru201-minggu-pertama/" class="text-black font-semibold text-gray-700">Redis University RU201 - Minggu Pertama</a></h2><p class="text-gray-700 leading-normal text-sm sm:text-base"><span>by <a href="/author/Muhammad%20Syifa/" class="text-gray-700 capitalize border-b border-transparent hover:border-gray-400 transition-border-color">Muhammad Syifa</a></span><!----></p></header><p class="leading-normal text-gray-700 text-lg px-2 sm:px-4 md:px-10">Ini adalah catatan minggu pertama dari apa yang saya pelajari di kelas RU201-nya Redis University yang berjudul "RediSearch".
Pada kelas ini, pembahasannya adalah tentang RediSearch, yaitu modul Redis yang berisi perlengkapan untuk melakukan pencarian berbasis memori dan melakuka ...</p></div></div></article></section><!----><footer class="text-gray-700 text-sm leading-normal flex flex-wrap justify-between mx-auto max-w-3xl px-6 sm:px-12 py-8 sm:py-16"><div class="w-full sm:w-1/2 mb-4 sm:mb-0"><p>© 2019</p></div><div class="w-full sm:w-1/2"><nav><ul class="flex sm:justify-end -mx-2"><li class="px-2"><a href="/" class="border-b border-transparent hover:border-gray-400 transition-border-color active">Home</a></li><li class="px-2"><a href="/sitemap.xml" class="border-b border-transparent hover:border-gray-400 transition-border-color">Sitemap</a></li><li class="px-2"><a href="/feed.xml" class="border-b border-transparent hover:border-gray-400 transition-border-color">RSS Feed</a></li></ul></nav></div></footer></main></div>
    <script>window.__INITIAL_STATE__={"data":{"tag":{"id":"RU201","title":"RU201","path":"\u002Ftag\u002FRU201","belongsTo":{"totalCount":1,"pageInfo":{"totalPages":1,"currentPage":1},"edges":[{"node":{"id":"a09ab95e3517e559565ab4d8a222ae85","title":"Redis University RU201 - Minggu Pertama","datetime":"2019-08-15 10:00:00","path":"\u002Fredis-university-ru201-minggu-pertama","content":"\u003Cp\u003EIni adalah catatan minggu pertama dari apa yang saya pelajari di kelas RU201-nya \u003Ca href=\"https:\u002F\u002Funiversity.redislabs.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERedis University\u003C\u002Fa\u003E yang berjudul \u003Cstrong\u003E\"RediSearch\"\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003EPada kelas ini, pembahasannya adalah tentang RediSearch, yaitu modul Redis yang berisi perlengkapan untuk melakukan pencarian berbasis memori dan melakukan secondary indexing.\u003C\u002Fp\u003E\n\u003Cp\u003EKelas RU201 yang saya ikuti ini dimulai pada 7 Agustus 2019, dan akan berjalan selama 6 minggu\ndimana 5 minggu pertama adalah pembelajaran, dan minggu terakhir adalah ujian.\nPada 5 minggu pertama, peserta dibagikan materi berupa video, quiz, dan diakhiri dengan PR mingguan.\nNilai dari PR mingguan akan diakumulasikan pada nilai akhir, jika nilai akhir mencapai 65% atau lebih, peserta akan diberikan sertifikat penyelesaian dari Redis University.\u003C\u002Fp\u003E\n\u003Cp\u003ESebagaimana kelas Redis University lainnya, RU201 juga memberikan Virtual Lab di setiap minggunya yang sudah terinstall Redis dan RediSearch.\u003C\u002Fp\u003E\n\u003Ch2 id=\"catatan-ru201-minggu-pertama\"\u003E\u003Ca href=\"#catatan-ru201-minggu-pertama\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ECatatan RU201 Minggu Pertama\u003C\u002Fh2\u003E\n\u003Cp\u003EPada minggu pertama, materi yang dibahas adalah:\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003ERedis Module\u003C\u002Fli\u003E\n\u003Cli\u003EKonsep Search Engine\u003C\u002Fli\u003E\n\u003Cli\u003EKonsep Secondary Index\u003C\u002Fli\u003E\n\u003Cli\u003ERediSearch vs Redis\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch4 id=\"1-redis-module\"\u003E\u003Ca href=\"#1-redis-module\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E1. Redis Module\u003C\u002Fh4\u003E\n\u003Cp\u003ERedis module adalah software tambahan untuk menambahkan fungsionalitas yang berbeda pada Redis.\nRedis module berbeda dengan Redis client yang dibahas pada kelas RU102J.\u003C\u002Fp\u003E\n\u003Cp\u003EBerikut adalah poin-poin penting tentang redis module.\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003ERedis module adalah compiled software.\u003C\u002Fli\u003E\n\u003Cli\u003ERedis module diimplementasikan sebagai sebuah shared object file (kurang tau maksudnya apa).\u003C\u002Fli\u003E\n\u003Cli\u003ERedis module berisi subroutines yang mengizinkan Redis server untuk terintegrasi dengannya saat runtime. Subroutines dipanggil oleh Redis melalui \u003Cem\u003Eforeign function interface\u003C\u002Fem\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003EUmumnya redis module dibuat menggunakan C, C++ dan Rust.\u003C\u002Fli\u003E\n\u003Cli\u003ERedis module dapat mengimplementasikan data type tersendiri diluar data types yang disediakan Redis.\u003C\u002Fli\u003E\n\u003Cli\u003ERedis module dapat menambahkan perintah-perintah baru pada Redis server.\u003C\u002Fli\u003E\n\u003Cli\u003EData type memiliki akses langsung ke memori, disimpan ke server, dan beroperasi dengan kecepatan dan efisiensi yang sama dengan built-in commands.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003ERedis module dapat diintegrasikan dengan beberapa cara:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EMelalui file redis.conf.\u003C\u002Fli\u003E\n\u003Cli\u003EMelalui command line argument.\u003C\u002Fli\u003E\n\u003Cli\u003EMelalui perintah \u003Ccode class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\"\u003EMODULE LOAD\u003C\u002Fcode\u003E pada redis-cli.\u003C\u002Fli\u003E\n\u003Cli\u003EMelalui Redis enterprise GUI.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch4 id=\"2-konsep-search-engine\"\u003E\u003Ca href=\"#2-konsep-search-engine\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E2. Konsep Search Engine\u003C\u002Fh4\u003E\n\u003Cp\u003EPada bagian ini yang pertama kali dibahas adalah tentang konsep dasar dari vocabulary pada search engine.\nUmumnya setiap indeks search engine terdiri dari sekumpulan dokumen. Setiap dokumen diidentifikasikan oleh ID yang terbuat dari sekumpulan field.\u003C\u002Fp\u003E\n\u003Cp\u003EBerikut poin-poin cukup penting untuk diingat:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EIndeks terdiri dari sekumpulan dokumen.\u003C\u002Fli\u003E\n\u003Cli\u003EIndeks dapat hanya berisi referensi dari dokumen tanpa menyimpan dokumen tersebut.\u003C\u002Fli\u003E\n\u003Cli\u003EIndeks tidak mengharuskan setiap field di dokumen untuk didefinisikan pada skema.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch6 id=\"tokenization\"\u003E\u003Ca href=\"#tokenization\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ETokenization\u003C\u002Fh6\u003E\n\u003Cp\u003EDBMS pada umumnya menyimpan teks sebagai binary-stream, sedangkan search engine perlu memahami bahasa manusia\nsehingga tidak dapat menyimpan teks sebagai binary-stream. Hal pertama yang dilakukan search engine adalah\nmengambil teks dan mengubahnya menjadi huruf kecil semua, lalu memecah teks-teks tersebut kedalam \u003Cem\u003Elogical-unit\u003C\u002Fem\u003E, alias token. Untuk mendapatkan token, diperlukan proses \u003Cem\u003Etokenization\u003C\u002Fem\u003E (tokenisasi).\u003C\u002Fp\u003E\n\u003Cp\u003ESebagai contoh, pada kalimat \"sebuah token adalah\", jika dilakukan proses tokenisasi akan menjadi 3 buah token:\n\"sebuah\", \"token\", dan \"adalah\".\u003C\u002Fp\u003E\n\u003Cp\u003EPada RediSearch, spasi bukan satu-satunya pemisah token. Melainkan hampir semua tanda baca adalah pemisah dari token, dan akan diabaikan.\u003C\u002Fp\u003E\n\u003Cp\u003ESebagai contoh saat kamu memiliki kalimat \"kamu adalah satu-satunya\", maka RediSearch akan memecahnya menjadi 4 buah token: \"kamu\", \"adalah\", \"satu\", \"satunya\".\u003C\u002Fp\u003E\n\u003Cp\u003EJika kamu menginginkan \"satu-satunya\" dianggap sebagai sebuah token, kamu dapat melakukan escaping dengan menambahkan karakter backslash \u003Ccode class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\"\u003E\\\u003C\u002Fcode\u003E pada karakter pemisah. Contoh: \"kamu adalah satu\\-satunya\".\u003C\u002Fp\u003E\n\u003Ch6 id=\"stop-words\"\u003E\u003Ca href=\"#stop-words\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EStop Words\u003C\u002Fh6\u003E\n\u003Cp\u003EStop words adalah daftar kata yang dianggap tidak penting (dapat diabaikan) sehingga perlu dihilangkan dari indeks.\nSebagai contoh adalah kata \"a\" (sebuah\u002Fseorang), kata tersebut sangat sering digunakan pada hampir semua dokumen, sehingga dirasa tidak perlu menyimpannya kedalam indeks.\u003C\u002Fp\u003E\n\u003Cp\u003EPada RediSearch daftar katayang masuk kedalam stop words (secara default) adalah:\u003C\u002Fp\u003E\n\u003Cpre class=\"shiki\" style=\"background-color: #ffffff\"\u003E\u003Ccode\u003E\u003Cspan style=\"color: #24292EFF\"\u003Ea,    is,    the,   an,   and,  are, as,  at,   be,   but,  by,   for,\u003C\u002Fspan\u003E\n\u003Cspan style=\"color: #24292EFF\"\u003Eif,   in,    into,  it,   no,   not, of,  on,   or,   such, that, their,\u003C\u002Fspan\u003E\n\u003Cspan style=\"color: #24292EFF\"\u003Ethen, there, these, they, this, to,  was, will, with\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EKata-kata tersebut secara default akan diabaikan oleh RediSearch, tidak akan dimasukkan kedalam indeks.\u003C\u002Fp\u003E\n\u003Ch5 id=\"stemming\"\u003E\u003Ca href=\"#stemming\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EStemming\u003C\u002Fh5\u003E\n\u003Cp\u003EStemming adalah proses mengubah kata pada setiap token menjadi kata dasarnya saja. Sebagai contoh kata \"menciptakan\", imbuhan \"men-kan\" akan dihapus, sehingga yang disimpan kedalam indeks hanya kata \"cipta\" saja. Kata kunci yang dimasukkan pada search engine juga dilakukan stemming. Dengan begini search engine yang dibuat jadi nggak kaku-kaku banget.\u003C\u002Fp\u003E\n\u003Cp\u003EDi RediSearch sendiri stemming bersifat optional, karena proses stemming ini cukup rumit untuk diadaptasi pada setiap bahasa, karena peraturan masing-masing bahasa yang cukup kompleks.\u003C\u002Fp\u003E\n\u003Ch4 id=\"3-konsep-secondary-index\"\u003E\u003Ca href=\"#3-konsep-secondary-index\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E3. Konsep Secondary Index\u003C\u002Fh4\u003E\n\u003Cp\u003ESecondary indeks seperti namanya adalah indeks kedua setelah indeks utama (primary index). Yang dimaksud kedua disini, jadi secondary index adalah index yang berisi indeks utama. Aduh bingung juga nulisnya.\u003C\u002Fp\u003E\n\u003Cp\u003EGini, misalkan di MySQL kita punya database customer yang berisi kolom \"ID\", \"email\", \"name\", \"phone\", \"dob\", dan \"city\", dimana kolom ID adalah primary key (primary index).\u003C\u002Fp\u003E\n\u003Cp\u003ESaat kita ingin mencari customer berdasarkan \"city\", untuk mempercepat pencarian kita membutuhkan secondary index yang berisi ID dari si customer. Nanti setelah ID-nya didapat, barulah kita mengambil data customer secara utuh.\u003C\u002Fp\u003E\n\u003Cp\u003EDisini RediSearch berperan sebagai secondary index dimana dia menyimpan field-field yang akan dilakukan pencarian, yang berisi primary index.\u003C\u002Fp\u003E\n\u003Cp\u003ERediSearch memiliki kelebihan sebagai secondary index yaitu sebagaimana Redis, RedisSearch menyimpan secondary index kedalam memory (bukan phisycal storage) sehingga performa lebih optimal.\u003C\u002Fp\u003E\n\u003Cp\u003EKekurangan menggunakan secondary index diantaranya:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EMeningkatkan kompleksitas untuk menjaga indeks supaya tetap sesuai dengan penyimpanan aslinya.\u003C\u002Fli\u003E\n\u003Cli\u003EBerpotensi out-of-date. Lagi-lagi kita harus menjaga indeks supaya sesuai dengan penyimpanan aslinya.\u003C\u002Fli\u003E\n\u003Cli\u003E2 stage latency. Karena kita memerlukan setidaknya 2 proses untuk setiap pencarian. Query ke RediSearch, kemudian query ke storage aslinya.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"4-redisearch-vs-redis\"\u003E\u003Ca href=\"#4-redisearch-vs-redis\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E4. RediSearch vs Redis\u003C\u002Fh4\u003E\n\u003Cp\u003ERediSearch memproses nilai berbeda dengan Redis biasa. Berikut adalah beberapa perbedannya.\u003C\u002Fp\u003E\n\u003Ch6 id=\"keyspaces-vs-index\"\u003E\u003Ca href=\"#keyspaces-vs-index\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EKeyspaces vs Index\u003C\u002Fh6\u003E\n\u003Cp\u003EPada RediSearch tidak berlaku one-key pattern seperti halnya Redis biasa. Setiap key pada RediSearch disimpan menggunakan key space khusus sehingga kita tidak dapat menggunakan perintah redis biasa pada key yang digunakan di RediSearch.\u003C\u002Fp\u003E\n\u003Ch6 id=\"field-types\"\u003E\u003Ca href=\"#field-types\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EField Types\u003C\u002Fh6\u003E\n\u003Cp\u003EAda 4 tipe data yang perlu diketahui pada RediSearch.\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003EText: untuk menyimpan teks. Untuk setiap skema dari dokumen, maksimal hanya boleh terdiri dari 128 text field. Text field dapat diberikan bobot dan dapat dilakukan sorting.\u003C\u002Fli\u003E\n\u003Cli\u003ENumeric: untuk menyimpan data non-tekstual. Tipe ini dapat dilakukan sorting dan ranging. \u003C\u002Fli\u003E\n\u003Cli\u003ETag: untuk menyimpan sekumpulan teks\u002Flabel\u002Fkategri. Berbeda dengan teks field, tag fields tidak diterapkan stemming dan stop words.\u003C\u002Fli\u003E\n\u003Cli\u003EGeo: untuk menyimpan latitude dan longitude. Tipe ini disimpan sebagai sorted-set pada Redis.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Chr\u003E\n\u003Cp\u003ESepertinya segitu aja yang perlu dicatat pada minggu pertama di RU201 ini. Yaudahlah sampai jumpa di catatan minggu berikutnya.\u003C\u002Fp\u003E\n","excerpt":"","description":"Catatan kelas Redis University RU102 minggu pertama","author":{"id":"Muhammad Syifa","title":"Muhammad Syifa","path":"\u002Fauthor\u002FMuhammad%20Syifa"}}}]}}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.163b108a.js" defer></script><script src="/assets/js/page--src-templates-tag-vue.eeb0f532.js" defer></script>
  </body>
</html>
