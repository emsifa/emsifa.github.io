{"hash":"6f8fcb1c91868a61025916ddaa1f2a89f2fea4b2","data":{"tag":{"id":"RU202","title":"RU202","path":"/tag/RU202/","belongsTo":{"totalCount":2,"pageInfo":{"totalPages":1,"currentPage":1},"edges":[{"node":{"id":"be8e7a02e0533f43d78409c7df8d067e","title":"Redis University RU202 - Minggu Ke-2","datetime":"2019-08-23 11:00:00","path":"/artikel/redis-university-ru202-minggu-ke-2/","icon":"/images/icons/redis.png","content":"<p>Ini adalah catatan minggu ke-2 dari apa yang saya pelajari di kelas RU202-nya <a href=\"https://university.redislabs.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis University</a> yang berjudul <strong>\"Redis Streams\"</strong>.</p>\n<p>Pada minggu ke-2 ini topik pembahasannya adalah:</p>\n<ol>\n<li>Producer</li>\n<li>Range Queries</li>\n<li>The Consumer</li>\n</ol>\n<h2 id=\"1-producer\"><a href=\"#1-producer\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. Producer</h2>\n<p>Pada bagian ini dijelaskan panjang lebar mengenai <em>stream producer</em>, disini saya rangkum saja kedalam beberapa poin dibawah ini: </p>\n<ul>\n<li><em>Stream Producer</em> adalah software/aplikasi yang berperan sebagai pengirim data kedalam stream.</li>\n<li>Data di dalam stream disebut sebagai 'message'.</li>\n<li><em>Stream Producer</em> menggunakan Redis Client API untuk memasukkan message kedalam stream.</li>\n<li>Pada Redis CLI, kita bisa menggunakan perintah <code>XADD stream_name message_id field value [field_2 value_2 ... field_n value_n]</code> untuk menambahkan message kedalam stream. Contoh untuk mengirim data temperatur kedalam stream: <code>XADD temperature * celcius 39</code>.</li>\n</ul>\n<h4 id=\"message-id\"><a href=\"#message-id\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Message ID</h4>\n<ul>\n<li>Untuk generate message ID secara otomatis, gunakan <code>*</code> (seperti contoh diatas). </li>\n<li>Message ID tidak dapat diubah.</li>\n<li>\n<p>Contoh message ID hasil generate: <code>1566533258158-0</code></p>\n<ul>\n<li><code>1566533258158</code>: <em>millisecond-timestamp</em>.</li>\n<li><code>0</code>: <em>sub-millisecond-sequence</em>, jika terdapat pesan dalam <em>millisecond-timestamp</em> yang sama, maka angka ini bertambah. Dan angka ini akan 0 kembali pada <em>millisecond-timestamp</em> yang berbeda.</li>\n</ul>\n</li>\n<li>\n<p>Contoh membuat message ID secara manual: <code>XADD mystream 100 x 1</code>.</p>\n<ul>\n<li>Message ID harus berupa unsigned integer (paling kecil 0).</li>\n<li>Hasil ID digenerate: <code>100-0</code> dimana <code>0</code> adalah urutan dari id <code>100</code>.</li>\n<li>Catatan: setelah menambahkan message dengan ID 100 kedalam stream mystream, maka kita tidak dapat menambahkan message dengan ID dibawah 100 kedalam stream mystream tersebut.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"message-payload\"><a href=\"#message-payload\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Message Payload</h4>\n<ul>\n<li>Message payload pada Redis Stream memiliki struktur data seperti hash (<code>Map&#x3C;String, String></code>).</li>\n<li>Tidak ada batasan berapa field yang dapat disimpan didalam setiap message.</li>\n<li>\n<p>Redis akan secara otomatis melakukan kompresi pada nama field di stream yang sama, contoh:</p>\n<ul>\n<li><code>XADD coordinates * latitude 0.1 longitude 1.0</code></li>\n<li><code>XADD coordinates * latitude 0.2 longitude 1.0</code></li>\n<li><code>XADD coordinates * latitude 0.3 longitude 1.1</code></li>\n<li>Pada 3 perintah <code>XADD</code> diatas, maka redis tidak akan menyimpan nama field <code>latitude</code> dan <code>longitude</code> pada 2 perintah <code>XADD</code> bawahnya.</li>\n<li>Tapi, jika perintah <code>XADD</code> selanjutnya memiliki field yang berbeda, entah ditambah field baru, atau ada field yang berubah, maka redis akan menyimpan nama field message tersebut secara utuh.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"managing-the-length-of-a-stream\"><a href=\"#managing-the-length-of-a-stream\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Managing the Length of a Stream</h4>\n<p>Untuk membatasi banyaknya message pada stream supaya tidak terlalu bengkak, dapat gunakan beberapa cara berikut:</p>\n<ol>\n<li>Gunakan <code>XADD</code> dengan <code>MAXLEN</code>. Contoh <code>XADD mystream * foo bar MAXLEN 1000</code>, maka jika ini adalah message yang ke-1001, message paling lama akan dihapus sehingga jumlah messagenya menjadi 1000.</li>\n<li>Gunakan perintah <code>XDEL</code>. Cara ini tidak dianjurkan karena tidak efektif.</li>\n<li>Gunakan perintah <code>XTRIM</code>. Contoh <code>XTRIM mystream MAXLEN 1000</code>, maka message ke 1001 sampai dengan yang paling lama akan dihapus.</li>\n</ol>\n<p>Yang saya masih bingung setelah melakukan proses diatas, message pada stream memang betul akan hilang,\ndalam artian ketika kita gunakan <code>XRANGE mystream - +</code> message yang terhapus tidak lagi muncul. Tetapi saat digunakan <code>MEMORY USAGE mystream</code>, memori yang terpakai masih sama. Dia ngasih tau sih memang saat menghapus message pada stream, message tidak secara langsung hilang, melainkan hanya diberi flag \"deleted\". Cuma yang masih belum saya tau, kapan memori tersebut benar-benar dihapus?</p>\n<p>Selain cara diatas, sebetulnya ada cara lain yang disarankan, yaitu menggunakan <code>XTRIM mystream MAXLEN ~ 1000</code>, atau <code>XADD mystream * foo bar MAXLEN ~ 1000</code>, ini penjelasan mereka tentang tanga <code>~</code>:</p>\n<blockquote>\n<p>The ~ argument between the MAXLEN option and the actual count means that the user is not really requesting that the stream length is exactly 1000 items, but instead it could be a few tens of entries more, but never less than 1000 items. When this option modifier is used, the trimming is performed only when Redis is able to remove a whole macro node. This makes it much more efficient, and it is usually what you want.</p>\n</blockquote>\n<p>Kenapa saya tidak masukkan cara ini di list, karena saya belum mengerti betul cara kerja si <code>~</code> itu.\nDisitu tertulis \"could be a few tens of entries more\", jadi saya coba buat stream dengan 100 message, dengan harapan setelah saya coba <code>XTRIM mystream MAXLEN ~ 10</code> maka akan menghapus <code>mystream</code> menjadi 10-50 message (few tens more). Tapi ternyata tidak terjadi apa-apa, <code>XLEN mystream</code> masih tetap 100.</p>\n<p>Entahlah, mungkin kalau messagenya ribuan bakal dihapus. Mungkin.</p>\n<h2 id=\"2-range-queries\"><a href=\"#2-range-queries\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. Range Queries</h2>\n<p>Untuk mengambil  message dalam range ID tertentu, dapat menggunakan perintah <code>XRANGE</code> dan <code>XREVRANGE</code>. Perbedaannya adalah <code>XRANGE</code> akan mengambil message dan mengurutkannya secara <em>ascending</em> (dari paling awal), <code>XREVRANGE</code> akan mengambil message dan mengurutkannya secara <em>descending</em> (dari paling akhir).</p>\n<p>Berikut contoh-contoh penggunaan <code>XRANGE</code> dan <code>XREVRANGE</code>:</p>\n<pre class=\"shiki\" style=\"background-color: #191d21\"><code><span style=\"color: #888\"># Beberapa cara mengambil semua message di dalam mystream</span>\n<span style=\"color: #FFFFFF\">XRANGE mystream - +</span>\n<span style=\"color: #FFFFFF\">XRANGE mystream 0-0 +</span>\n\n<span style=\"color: #888\"># Mengambil semua message dari 1526985054069-0 s/d data terakhir di dalam mystream</span>\n<span style=\"color: #FFFFFF\">XRANGE mystream 1526985054069-0 +</span>\n\n<span style=\"color: #888\"># Mengambil semua message diantara 1526985054069-0 s/d 1531243452312-0 terakhir di dalam mystream</span>\n<span style=\"color: #FFFFFF\">XRANGE mystream 1526985054069-0 1531243452312-0</span>\n\n<span style=\"color: #888\"># Mengambil 10 message PERTAMA dari mystream</span>\n<span style=\"color: #FFFFFF\">XRANGE mystream - + COUNT 10</span>\n\n<span style=\"color: #888\"># Mengambil 10 message TERAKHIR dari mystream</span>\n<span style=\"color: #FFFFFF\">XREVRANGE mystream + - COUNT 10</span></code></pre>\n<p>Tanda <code>-</code> dan <code>+</code> adalah special ID, <code>-</code> adalah alias untuk ID awal (0-0), sedangkan <code>+</code> adalah alias untuk ID terakhir (18446744073709551615-18446744073709551615).</p>\n<h2 id=\"3-the-consumer\"><a href=\"#3-the-consumer\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. The Consumer</h2>\n<p>Untuk men-<em>consume</em> data pada stream, dapat menggunakan perintah <code>XREAD</code>. Berikut adalah beberapa contoh penggunaan <code>XREAD</code>.</p>\n<pre class=\"shiki\" style=\"background-color: #191d21\"><code><span style=\"color: #FFFFFF\">XREAD COUNT 1 STREAMS mystream</span></code></pre>\n","excerpt":"","description":"Catatan kelas Redis University RU102 minggu ke-2","author":{"id":"Muhammad Syifa","title":"Muhammad Syifa","path":"/author/Muhammad%20Syifa/"}}},{"node":{"id":"7240487eb4ae485b30c3e42652d19ff3","title":"Redis University RU202 - Minggu Pertama","datetime":"2019-08-15 11:00:00","path":"/artikel/redis-university-ru202-minggu-pertama/","icon":"/images/icons/redis.png","content":"<p>Ini adalah catatan minggu pertama dari apa yang saya pelajari di kelas RU202-nya <a href=\"https://university.redislabs.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis University</a> yang berjudul <strong>\"Redis Streams\"</strong>.</p>\n<p>Sesuai judulnya, pada kelas ini pembahasannya adalah tentang Redis Stream, fitur pada Redis yang diperuntukkan untuk membuat messaging dan streaming pipelines.</p>\n<p>Kelas RU202 yang saya ikuti ini dimulai pada 7 Agustus 2019, dan akan berjalan selama 5 minggu\ndimana 4 minggu pertama adalah pembelajaran, dan minggu terakhir adalah ujian.\nPada 4 minggu pertama, peserta dibagikan materi berupa video, quiz, dan diakhiri dengan PR mingguan.\nNilai dari PR mingguan akan diakumulasikan pada nilai akhir, jika nilai akhir mencapai 64% atau lebih, peserta akan diberikan sertifikat penyelesaian dari Redis University.</p>\n<p>Sebagaimana kelas Redis University lainnya, RU202 juga memberikan Virtual Lab di setiap minggunya yang sudah terinstall Redis.</p>\n<h2 id=\"catatan-ru202-minggu-pertama\"><a href=\"#catatan-ru202-minggu-pertama\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Catatan RU202 Minggu Pertama</h2>\n<p>Pada minggu pertama ini, yang dibahas adalah:</p>\n<ol>\n<li>Pengenalan Distributed Systems dan Stream Processing</li>\n<li>Pengenalan Redis Streams</li>\n</ol>\n<h4 id=\"1-pengenalan-distributed-systems-dan-stream-processing\"><a href=\"#1-pengenalan-distributed-systems-dan-stream-processing\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. Pengenalan Distributed Systems dan Stream Processing</h4>\n<h6 id=\"distributed-systems\"><a href=\"#distributed-systems\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Distributed Systems</h6>\n<p>Distributed systems adalah sebuah setup (pengaturan) yang terdiri dari berbagai komponen jaringan yang saling melakukan perpesanan (messaging) satu sama lain. Redis sendiri didesain untuk menjadi salah satu komponen tersebut, dimana nama Redis merupakan singkatan dari \"<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver\". Kata \"remote\" berarti dapat diakses melalui jaringan, sedangkan kara \"server\" menunjukkan rolenya pada paradigma client-server. Jadi kata Redis sendiri dapat diartikan sebagai server yang berperan sebagai bagian dari setup dimana komponen-komponen (pada distributed system) lain berkomunikasi dengannya, juga menjadi perantara antara setiap komponen untuk berkomunikasi satu sama lain.</p>\n<p>Membuat distributed system memiliki tantangan tersendiri dalam menghadapi kegagalan (failures). Saat salah satu komponen mengalami kegagalan (mati), komponen tersebut jadi tidak dapat menerima pesan apapun dari komponen lain, bahkan pesan yang sedang diproses sebelum dia mati juga ikut hilang. Kehilangan sebuah komponen dalam distributed system adalah hal yang tidak dapat dicegah. Oleh karena itu distributed system yang dibuat harus dirancang sedemikian rupa untuk menghadapi kemungkinan tersebut.</p>\n<p>Messaging adalah komponen yang cukup penting dalam sebuah distributed system, karena dia mengendalikan global-state yang digunakan oleh komponen-komponen lain. </p>\n<p>Pada versi 5.0, Redis sudah mendukung distributed messaging. Messaging pada Redis dirancang khusus untuk unggul dalam performa dibanding beberapa alternatif message broker lainnya.</p>\n<h6 id=\"stream-processing\"><a href=\"#stream-processing\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Stream Processing</h6>\n<p>Setiap distributed system bergantung pada komponen messaging untuk mengendalikan atau mengkoordinasikan komponen-komponen lain. Beberapa sistem dibangun untuk dapat menangani data yang dikirimkan secara terus-menerus, dan bereaksi secara instan saat terdapat perubahan pada data. Pada era big data, hal ini disebut stream processing, dipopulerkan oleh Apache Storm dan beberapa konsep lain yang sudah hadir sebelumnya.</p>\n<p>Stream processing adalah kebalikan dari batch processing.</p>\n<p>Contoh populer dari stream processing adalah monitoring suhu. Sensor suhu akan membaca suhu setiap sepersekian detik, kemudian sensor akan mengirimkannya secara terus menerus (streaming) data tersebut ke stream processor. Kemudian stream processor akan mengecek, jika suhu melewati batas yang ditentukan, stream processor secara real-time akan mengirimkan notifikasi ke smartpohne pengguna.</p>\n<h4 id=\"2-pengenalan-redis-stream\"><a href=\"#2-pengenalan-redis-stream\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. Pengenalan Redis Stream</h4>\n<p>Pada versi 5.0 Redis mendukung struktur data untuk melakukan stream yang diberi nama Redis Stream.</p>\n<p>Berikut beberapa poin penting tentang Redis Stream:</p>\n<ol>\n<li>Redis Stream adalah struktur data.</li>\n<li>Bertindak seperti <em>append-only</em> list. Tidak seperti list yang bisa ditambahkan nilai pada index tertentu, stream hanya dapat ditambahkan di akhir. Jadi mulai sekarang bayangin Redis Stream ini adalah array.</li>\n<li>Setiap item didalam Redis Stream adalah Hash (semacam <code>Map&#x3C;String, String></code> kalau di Java).</li>\n<li>Setiap item didalam Redis Stream diidentifikasikan oleh ID unik, dimana secara default ID adalah <em>time-prefixed</em> (diawali informasi waktu).</li>\n<li>Mendukung ID-based range queries. Kalau ibarat SQL di RDBMS, dia mendukung semacam: <code>select from streamnya where timenya between timeA and timeB</code>.</li>\n<li>Setiap Redis Stream dapat dikonsumsi oleh banyak kelompok consumer atau yang disebut sebagai consumer group.</li>\n<li>Redis stream bersifat immutable, sekali di append, data tidak dapat diubah.</li>\n<li>Setiap item didalam Redis Stream dapat dihapus, tetapi Redis hanya memberi flag \"terhapus\", datanya sendiri sebetulnya masih ada, tetapi tidak akan muncul saat diquery.</li>\n</ol>\n<p>Sebelumnya Redis memiliki fitur Redis Pub/Sub, lalu apa bedanya dengan Redis Stream?</p>\n<p>Perbedaannya adalah, jika pada Pub/Sub, client hanya menerima data yang dipublish (dikirim) <strong>setelah dia terhubung</strong>. Sedangkan pada Redis Stream, client yang baru terhubung akan menerima data stream yang dikirim <strong>sebelum dia terhubung</strong>. Dengan kata lain pada Pub/Sub memori akan dihapus setelah publish selesai dilakukan, sedangkan pada Redis Stream memori (data streamnya) tetap disimpan untuk dikirimkan nanti saat ada client baru yang terhubung.</p>\n<hr>\n<p>Segitu aja mungkin untuk RU202 ini yang perlu saya catat. Yaudahlah, sampai jumpa di catatan minggu depan.</p>\n","excerpt":"","description":"Catatan kelas Redis University RU102 minggu pertama","author":{"id":"Muhammad Syifa","title":"Muhammad Syifa","path":"/author/Muhammad%20Syifa/"}}}]}}},"context":{}}