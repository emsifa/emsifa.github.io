{"hash":"586cd63966c7128a0c39d0e611e6943ac180ba39","data":{"post":{"title":"Redis University RU201 - Minggu Pertama","slug":"redis-university-ru201-minggu-pertama","datetime":"2019-08-15 10:00:00","content":"<p>Ini adalah catatan minggu pertama dari apa yang saya pelajari di kelas RU201-nya <a href=\"https://university.redislabs.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis University</a> yang berjudul <strong>\"RediSearch\"</strong>.</p>\n<p>Pada kelas ini, pembahasannya adalah tentang RediSearch, yaitu modul Redis yang berisi perlengkapan untuk melakukan pencarian berbasis memori dan melakukan secondary indexing.</p>\n<p>Kelas RU201 yang saya ikuti ini dimulai pada 7 Agustus 2019, dan akan berjalan selama 6 minggu\ndimana 5 minggu pertama adalah pembelajaran, dan minggu terakhir adalah ujian.\nPada 5 minggu pertama, peserta dibagikan materi berupa video, quiz, dan diakhiri dengan PR mingguan.\nNilai dari PR mingguan akan diakumulasikan pada nilai akhir, jika nilai akhir mencapai 65% atau lebih, peserta akan diberikan sertifikat penyelesaian dari Redis University.</p>\n<p>Sebagaimana kelas Redis University lainnya, RU201 juga memberikan Virtual Lab di setiap minggunya yang sudah terinstall Redis dan RediSearch.</p>\n<h2 id=\"catatan-ru201-minggu-pertama\"><a href=\"#catatan-ru201-minggu-pertama\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Catatan RU201 Minggu Pertama</h2>\n<p>Pada minggu pertama, materi yang dibahas adalah:</p>\n<ol>\n<li>Redis Module</li>\n<li>Konsep Search Engine</li>\n<li>Konsep Secondary Index</li>\n<li>RediSearch vs Redis</li>\n</ol>\n<h4 id=\"1-redis-module\"><a href=\"#1-redis-module\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. Redis Module</h4>\n<p>Redis module adalah software tambahan untuk menambahkan fungsionalitas yang berbeda pada Redis.\nRedis module berbeda dengan Redis client yang dibahas pada kelas RU201J.</p>\n<p>Berikut adalah poin-poin penting tentang redis module.</p>\n<ol>\n<li>Redis module adalah compiled software.</li>\n<li>Redis module diimplementasikan sebagai sebuah shared object file (kurang tau maksudnya apa).</li>\n<li>Redis module berisi subroutines yang mengizinkan Redis server untuk terintegrasi dengannya saat runtime. Subroutines dipanggil oleh Redis melalui <em>foreign function interface</em>.</li>\n<li>Umumnya redis module dibuat menggunakan C, C++ dan Rust.</li>\n<li>Redis module dapat mengimplementasikan data type tersendiri diluar data types yang disediakan Redis.</li>\n<li>Redis module dapat menambahkan perintah-perintah baru pada Redis server.</li>\n<li>Data type memiliki akses langsung ke memori, disimpan ke server, dan beroperasi dengan kecepatan dan efisiensi yang sama dengan built-in commands.</li>\n<li>\n<p>Redis module dapat diintegrasikan dengan beberapa cara:</p>\n<ul>\n<li>Melalui file redis.conf.</li>\n<li>Melalui command line argument.</li>\n<li>Melalui perintah <code>MODULE LOAD</code> pada redis-cli.</li>\n<li>Melalui Redis enterprise GUI.</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-konsep-search-engine\"><a href=\"#2-konsep-search-engine\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. Konsep Search Engine</h4>\n<p>Pada bagian ini yang pertama kali dibahas adalah tentang konsep dasar dari vocabulary pada search engine.\nUmumnya setiap indeks search engine terdiri dari sekumpulan dokumen. Setiap dokumen diidentifikasikan oleh ID yang terbuat dari sekumpulan field.</p>\n<p>Berikut poin-poin cukup penting untuk diingat:</p>\n<ul>\n<li>Indeks terdiri dari sekumpulan dokumen.</li>\n<li>Indeks dapat hanya berisi referensi dari dokumen tanpa menyimpan dokumen tersebut.</li>\n<li>Indeks tidak mengharuskan setiap field di dokumen untuk didefinisikan pada skema.</li>\n</ul>\n<h6 id=\"tokenization\"><a href=\"#tokenization\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Tokenization</h6>\n<p>DBMS pada umumnya menyimpan teks sebagai binary-stream, sedangkan search engine perlu memahami bahasa manusia\nsehingga tidak dapat menyimpan teks sebagai binary-stream. Hal pertama yang dilakukan search engine adalah\nmengambil teks dan mengubahnya menjadi huruf kecil semua, lalu memecah teks-teks tersebut kedalam <em>logical-unit</em>, alias token. Untuk mendapatkan token, diperlukan proses <em>tokenization</em> (tokenisasi).</p>\n<p>Sebagai contoh, pada kalimat \"sebuah token adalah\", jika dilakukan proses tokenisasi akan menjadi 3 buah token:\n\"sebuah\", \"token\", dan \"adalah\".</p>\n<p>Pada RediSearch, spasi bukan satu-satunya pemisah token. Melainkan hampir semua tanda baca adalah pemisah dari token, dan akan diabaikan.</p>\n<p>Sebagai contoh saat kamu memiliki kalimat \"kamu adalah satu-satunya\", maka RediSearch akan memecahnya menjadi 4 buah token: \"kamu\", \"adalah\", \"satu\", \"satunya\".</p>\n<p>Jika kamu menginginkan \"satu-satunya\" dianggap sebagai sebuah token, kamu dapat melakukan escaping dengan menambahkan karakter backslash <code>\\</code> pada karakter pemisah. Contoh: \"kamu adalah satu\\-satunya\".</p>\n<h6 id=\"stop-words\"><a href=\"#stop-words\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Stop Words</h6>\n<p>Stop words adalah daftar kata yang dianggap tidak penting (dapat diabaikan) sehingga perlu dihilangkan dari indeks.\nSebagai contoh adalah kata \"a\" (sebuah/seorang), kata tersebut sangat sering digunakan pada hampir semua dokumen, sehingga dirasa tidak perlu menyimpannya kedalam indeks.</p>\n<p>Pada RediSearch daftar katayang masuk kedalam stop words (secara default) adalah:</p>\n<pre class=\"shiki\" style=\"background-color: #191d21\"><code><span style=\"color: #FFFFFF\">a,    is,    the,   an,   and,  are, as,  at,   be,   but,  by,   for,</span>\n<span style=\"color: #FFFFFF\">if,   in,    into,  it,   no,   not, of,  on,   or,   such, that, their,</span>\n<span style=\"color: #FFFFFF\">then, there, these, they, this, to,  was, will, with</span></code></pre>\n<p>Kata-kata tersebut secara default akan diabaikan oleh RediSearch, tidak akan dimasukkan kedalam indeks.</p>\n<h5 id=\"stemming\"><a href=\"#stemming\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Stemming</h5>\n<p>Stemming adalah proses mengubah kata pada setiap token menjadi kata dasarnya saja. Sebagai contoh kata \"menciptakan\", imbuhan \"men-kan\" akan dihapus, sehingga yang disimpan kedalam indeks hanya kata \"cipta\" saja. Kata kunci yang dimasukkan pada search engine juga dilakukan stemming. Dengan begini search engine yang dibuat jadi nggak kaku-kaku banget.</p>\n<p>Di RediSearch sendiri stemming bersifat optional, karena proses stemming ini cukup rumit untuk diadaptasi pada setiap bahasa, karena peraturan masing-masing bahasa yang cukup kompleks.</p>\n<h4 id=\"3-konsep-secondary-index\"><a href=\"#3-konsep-secondary-index\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. Konsep Secondary Index</h4>\n<p>Secondary indeks seperti namanya adalah indeks kedua setelah indeks utama (primary index). Yang dimaksud kedua disini, jadi secondary index adalah index yang berisi indeks utama. Aduh bingung juga nulisnya.</p>\n<p>Gini, misalkan di MySQL kita punya database customer yang berisi kolom \"ID\", \"email\", \"name\", \"phone\", \"dob\", dan \"city\", dimana kolom ID adalah primary key (primary index).</p>\n<p>Saat kita ingin mencari customer berdasarkan \"city\", untuk mempercepat pencarian kita membutuhkan secondary index yang berisi ID dari si customer. Nanti setelah ID-nya didapat, barulah kita mengambil data customer secara utuh.</p>\n<p>Disini RediSearch berperan sebagai secondary index dimana dia menyimpan field-field yang akan dilakukan pencarian, yang berisi primary index.</p>\n<p>RediSearch memiliki kelebihan sebagai secondary index yaitu sebagaimana Redis, RedisSearch menyimpan secondary index kedalam memory (bukan phisycal storage) sehingga performa lebih optimal.</p>\n<p>Kekurangan menggunakan secondary index diantaranya:</p>\n<ul>\n<li>Meningkatkan kompleksitas untuk menjaga indeks supaya tetap sesuai dengan penyimpanan aslinya.</li>\n<li>Berpotensi out-of-date. Lagi-lagi kita harus menjaga indeks supaya sesuai dengan penyimpanan aslinya.</li>\n<li>2 stage latency. Karena kita memerlukan setidaknya 2 proses untuk setiap pencarian. Query ke RediSearch, kemudian query ke storage aslinya.</li>\n</ul>\n<h4 id=\"4-redisearch-vs-redis\"><a href=\"#4-redisearch-vs-redis\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>4. RediSearch vs Redis</h4>\n<p>RediSearch memproses nilai berbeda dengan Redis biasa. Berikut adalah beberapa perbedannya.</p>\n<h6 id=\"keyspaces-vs-index\"><a href=\"#keyspaces-vs-index\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Keyspaces vs Index</h6>\n<p>Pada RediSearch tidak berlaku one-key pattern seperti halnya Redis biasa. Setiap key pada RediSearch disimpan menggunakan key space khusus sehingga kita tidak dapat menggunakan perintah redis biasa pada key yang digunakan di RediSearch.</p>\n<h6 id=\"field-types\"><a href=\"#field-types\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Field Types</h6>\n<p>Ada 4 tipe data yang perlu diketahui pada RediSearch.</p>\n<ol>\n<li>Text: untuk menyimpan teks. Untuk setiap skema dari dokumen, maksimal hanya boleh terdiri dari 128 text field. Text field dapat diberikan bobot dan dapat dilakukan sorting.</li>\n<li>Numeric: untuk menyimpan data non-tekstual. Tipe ini dapat dilakukan sorting dan ranging. </li>\n<li>Tag: untuk menyimpan sekumpulan teks/label/kategri. Berbeda dengan teks field, tag fields tidak diterapkan stemming dan stop words.</li>\n<li>Geo: untuk menyimpan latitude dan longitude. Tipe ini disimpan sebagai sorted-set pada Redis.</li>\n</ol>\n<hr>\n<p>Sepertinya segitu aja yang perlu dicatat pada minggu pertama di RU201 ini. Yaudahlah sampai jumpa di catatan minggu berikutnya.</p>\n","description":"Catatan kelas Redis University RU201 minggu pertama","timeToRead":5,"cover":"/images/posts/ru201-w1-cover.png","coverThumb":"/images/posts/ru201-w1-cover.png","fullscreen":false,"author":{"id":"Muhammad Syifa","title":"Muhammad Syifa","path":"/author/Muhammad%20Syifa/"},"tags":[{"id":"Redis University","title":"Redis University","path":"/tag/Redis%20University/"},{"id":"Course","title":"Course","path":"/tag/Course/"},{"id":"RU201","title":"RU201","path":"/tag/RU201/"}]}},"context":{}}