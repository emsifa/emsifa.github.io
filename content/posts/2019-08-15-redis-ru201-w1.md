---
title: "Redis University RU201 - Minggu Pertama"
slug: redis-university-ru201-minggu-pertama
description: "Catatan kelas Redis University RU201 minggu pertama"
date: 2019-08-15 10:00:00
author: Muhammad Syifa
icon: "/images/icons/redis.png"
cover: "/images/posts/ru201-w1-cover.png"
fullscreen: false
tags:
    - Redis University
    - Course
    - RU201
---

Ini adalah catatan minggu pertama dari apa yang saya pelajari di kelas RU201-nya [Redis University](https://university.redislabs.com) yang berjudul **"RediSearch"**.

Pada kelas ini, pembahasannya adalah tentang RediSearch, yaitu modul Redis yang berisi perlengkapan untuk melakukan pencarian berbasis memori dan melakukan secondary indexing.

Kelas RU201 yang saya ikuti ini dimulai pada 7 Agustus 2019, dan akan berjalan selama 6 minggu
dimana 5 minggu pertama adalah pembelajaran, dan minggu terakhir adalah ujian.
Pada 5 minggu pertama, peserta dibagikan materi berupa video, quiz, dan diakhiri dengan PR mingguan.
Nilai dari PR mingguan akan diakumulasikan pada nilai akhir, jika nilai akhir mencapai 65% atau lebih, peserta akan diberikan sertifikat penyelesaian dari Redis University.

Sebagaimana kelas Redis University lainnya, RU201 juga memberikan Virtual Lab di setiap minggunya yang sudah terinstall Redis dan RediSearch.

## Catatan RU201 Minggu Pertama

Pada minggu pertama, materi yang dibahas adalah:

1. Redis Module
2. Konsep Search Engine
3. Konsep Secondary Index
4. RediSearch vs Redis

#### 1. Redis Module

Redis module adalah software tambahan untuk menambahkan fungsionalitas yang berbeda pada Redis.
Redis module berbeda dengan Redis client yang dibahas pada kelas RU201J.

Berikut adalah poin-poin penting tentang redis module.

1. Redis module adalah compiled software.
2. Redis module diimplementasikan sebagai sebuah shared object file (kurang tau maksudnya apa).
3. Redis module berisi subroutines yang mengizinkan Redis server untuk terintegrasi dengannya saat runtime. Subroutines dipanggil oleh Redis melalui _foreign function interface_.
4. Umumnya redis module dibuat menggunakan C, C++ dan Rust.
5. Redis module dapat mengimplementasikan data type tersendiri diluar data types yang disediakan Redis.
6. Redis module dapat menambahkan perintah-perintah baru pada Redis server.
7. Data type memiliki akses langsung ke memori, disimpan ke server, dan beroperasi dengan kecepatan dan efisiensi yang sama dengan built-in commands.
8. Redis module dapat diintegrasikan dengan beberapa cara:
   * Melalui file redis.conf.
   * Melalui command line argument.
   * Melalui perintah `MODULE LOAD` pada redis-cli.
   * Melalui Redis enterprise GUI.

#### 2. Konsep Search Engine

Pada bagian ini yang pertama kali dibahas adalah tentang konsep dasar dari vocabulary pada search engine.
Umumnya setiap indeks search engine terdiri dari sekumpulan dokumen. Setiap dokumen diidentifikasikan oleh ID yang terbuat dari sekumpulan field.

Berikut poin-poin cukup penting untuk diingat:

* Indeks terdiri dari sekumpulan dokumen.
* Indeks dapat hanya berisi referensi dari dokumen tanpa menyimpan dokumen tersebut.
* Indeks tidak mengharuskan setiap field di dokumen untuk didefinisikan pada skema.

###### Tokenization

DBMS pada umumnya menyimpan teks sebagai binary-stream, sedangkan search engine perlu memahami bahasa manusia
sehingga tidak dapat menyimpan teks sebagai binary-stream. Hal pertama yang dilakukan search engine adalah
mengambil teks dan mengubahnya menjadi huruf kecil semua, lalu memecah teks-teks tersebut kedalam _logical-unit_, alias token. Untuk mendapatkan token, diperlukan proses _tokenization_ (tokenisasi).

Sebagai contoh, pada kalimat "sebuah token adalah", jika dilakukan proses tokenisasi akan menjadi 3 buah token:
"sebuah", "token", dan "adalah".

Pada RediSearch, spasi bukan satu-satunya pemisah token. Melainkan hampir semua tanda baca adalah pemisah dari token, dan akan diabaikan.

Sebagai contoh saat kamu memiliki kalimat "kamu adalah satu-satunya", maka RediSearch akan memecahnya menjadi 4 buah token: "kamu", "adalah", "satu", "satunya".

Jika kamu menginginkan "satu-satunya" dianggap sebagai sebuah token, kamu dapat melakukan escaping dengan menambahkan karakter backslash `\` pada karakter pemisah. Contoh: "kamu adalah satu\\-satunya".

###### Stop Words

Stop words adalah daftar kata yang dianggap tidak penting (dapat diabaikan) sehingga perlu dihilangkan dari indeks.
Sebagai contoh adalah kata "a" (sebuah/seorang), kata tersebut sangat sering digunakan pada hampir semua dokumen, sehingga dirasa tidak perlu menyimpannya kedalam indeks.

Pada RediSearch daftar katayang masuk kedalam stop words (secara default) adalah:

```bash
a,    is,    the,   an,   and,  are, as,  at,   be,   but,  by,   for,
if,   in,    into,  it,   no,   not, of,  on,   or,   such, that, their,
then, there, these, they, this, to,  was, will, with
```

Kata-kata tersebut secara default akan diabaikan oleh RediSearch, tidak akan dimasukkan kedalam indeks.

##### Stemming

Stemming adalah proses mengubah kata pada setiap token menjadi kata dasarnya saja. Sebagai contoh kata "menciptakan", imbuhan "men-kan" akan dihapus, sehingga yang disimpan kedalam indeks hanya kata "cipta" saja. Kata kunci yang dimasukkan pada search engine juga dilakukan stemming. Dengan begini search engine yang dibuat jadi nggak kaku-kaku banget.

Di RediSearch sendiri stemming bersifat optional, karena proses stemming ini cukup rumit untuk diadaptasi pada setiap bahasa, karena peraturan masing-masing bahasa yang cukup kompleks.


#### 3. Konsep Secondary Index

Secondary indeks seperti namanya adalah indeks kedua setelah indeks utama (primary index). Yang dimaksud kedua disini, jadi secondary index adalah index yang berisi indeks utama. Aduh bingung juga nulisnya.

Gini, misalkan di MySQL kita punya database customer yang berisi kolom "ID", "email", "name", "phone", "dob", dan "city", dimana kolom ID adalah primary key (primary index).

Saat kita ingin mencari customer berdasarkan "city", untuk mempercepat pencarian kita membutuhkan secondary index yang berisi ID dari si customer. Nanti setelah ID-nya didapat, barulah kita mengambil data customer secara utuh.

Disini RediSearch berperan sebagai secondary index dimana dia menyimpan field-field yang akan dilakukan pencarian, yang berisi primary index.

RediSearch memiliki kelebihan sebagai secondary index yaitu sebagaimana Redis, RedisSearch menyimpan secondary index kedalam memory (bukan phisycal storage) sehingga performa lebih optimal.

Kekurangan menggunakan secondary index diantaranya:

* Meningkatkan kompleksitas untuk menjaga indeks supaya tetap sesuai dengan penyimpanan aslinya.
* Berpotensi out-of-date. Lagi-lagi kita harus menjaga indeks supaya sesuai dengan penyimpanan aslinya.
* 2 stage latency. Karena kita memerlukan setidaknya 2 proses untuk setiap pencarian. Query ke RediSearch, kemudian query ke storage aslinya.

#### 4. RediSearch vs Redis

RediSearch memproses nilai berbeda dengan Redis biasa. Berikut adalah beberapa perbedannya.

###### Keyspaces vs Index

Pada RediSearch tidak berlaku one-key pattern seperti halnya Redis biasa. Setiap key pada RediSearch disimpan menggunakan key space khusus sehingga kita tidak dapat menggunakan perintah redis biasa pada key yang digunakan di RediSearch.

###### Field Types

Ada 4 tipe data yang perlu diketahui pada RediSearch.

1. Text: untuk menyimpan teks. Untuk setiap skema dari dokumen, maksimal hanya boleh terdiri dari 128 text field. Text field dapat diberikan bobot dan dapat dilakukan sorting.
2. Numeric: untuk menyimpan data non-tekstual. Tipe ini dapat dilakukan sorting dan ranging. 
3. Tag: untuk menyimpan sekumpulan teks/label/kategri. Berbeda dengan teks field, tag fields tidak diterapkan stemming dan stop words.
4. Geo: untuk menyimpan latitude dan longitude. Tipe ini disimpan sebagai sorted-set pada Redis.

---

Sepertinya segitu aja yang perlu dicatat pada minggu pertama di RU201 ini. Yaudahlah sampai jumpa di catatan minggu berikutnya.
