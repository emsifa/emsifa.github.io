---
title: "Redis University RU101 - Minggu Pertama"
slug: redis-university-ru101-minggu-pertama
description: "Catatan kelas Redis University RU101 minggu pertama"
date: 2019-08-15 08:00:00
author: Muhammad Syifa
icon: "/images/icons/redis.png"
cover: "/images/posts/ru101-w1-cover.png"
fullscreen: false
tags:
    - Redis University
    - Course
    - RU101
---

Ini adalah catatan minggu pertama dari apa yang saya pelajari di kelas RU101-nya [Redis University](https://university.redislabs.com) yang berjudul **"Introduction to Redis Data Structures"**.

Karena RU101 ini adalah kelas paling dasar dari Redis University, dan karena ini adalah minggu pertama, saya jelasin dulu lah ya Redis University itu apa, dan bagaimana cara kerjanya.

## Apaan si Redis University?

Redis University adalah Universitas Redis (wawasanku luas sekali :p). Ya pokoknya seperti namanya,
Redis University ini adalah situs belajar online gratis yang dibuat oleh [Redis Lab](https://www.redislabs.com) <span>&mdash;</span> sang pencipta [Redis](https://www.redis.io), yang tentunya berisi kelas-kelas yang membahas tentang Redis. Kalau kamu ga tau apa itu Redis, cari tau dulu gih sana. Hush hush ~ #ngusir

Saat tulisan ini dibuat, baru ada 5 kelas yang tersedia pada 'Universitas' ini. Saya sendiri ikut 4 kelas yang salah satunya adalah si RU101.

---

"Kok nanggung nggak 5-5nya? sebagai orang Indonesia yang baik dan benar kamu harusnya borong semua 'benda' gratisan ini dong!"

Tenang kawan, sebagai orang Indonesia yang baik dan benar saya juga paham itu. Saya nggak ikut yang satunya bukan karena saya nggak mau, tapi karena kelas yang 1 lagi baru dibuka musim gugur nanti.

Eh, fall itu musim gugur kan ya? pokoknya gitulah. #BodoAmat

---

## Pengenalan RU101

Kelas RU101 yang saya ikuti ini dimulai pada 7 Agustus 2019, dan akan berjalan selama 6 minggu
dimana 5 minggu pertama adalah pembelajaran, dan minggu terakhir adalah ujian.
Pada 5 minggu pertama, peserta dibagikan materi berupa video, quiz, dan diakhiri dengan PR mingguan.
Nilai dari PR mingguan akan diakumulasikan pada nilai akhir, jika nilai akhir mencapai 65% atau lebih, peserta akan diberikan sertifikat penyelesaian dari Redis University.

Yang menarik dari kelasnya si Redis University ini, dia memberikan Virtual Lab setiap minggunya yang bisa kita gunakan
untuk ~~mining~~ coba-coba materi yang diajarkan. Di Virtual Lab ini sudah terinstall Redis, Python, Java, Web IDE, dsb, yaa pokoknya software-softare yang dibutuhkan pada minggu itu udah diinstalin, bahkan source code dan sample datanya sudah disediakan. Peserta tinggal gunain doang.

Kebetulan sekarang saya sehari-harinya pakai Windows 10 Home Edition (bawaan laptop) yang belum mendukung Redis secara native, jadi kebantu banget sama Virtual Lab ini. 

## Catatan RU101 Minggu Pertama

Oke sekarang kita masuk ke inti dari tulisan ini. Oia karena status saya disini adalah pelajar, 
jadi kalau ada salah-salah silahkan aja di koreksi. Asal jangan caci-maki, nanti saya nangis, saya aduin kamu ke mama saya. #TukangNgadu

Seperti yang tertulis di paragraf pertama, kelas RU101 ini membahas tentang "Introduction to Redis Data Structures",
yang kalau diterjemahkan ke bahasa Rumania berarti "Introducere Ã®n structurile de date Redis". #WawPentingSekali

Pada minggu pertama ini, yang dibahas adalah:

1. Keys
2. Strings
3. Hashes
4. Lists
5. Sets
6. Sorted Sets

Mari ~~kita~~ saya bahas satu persatu.

#### 1. Keys

Keys adalah cara utama untuk mengakses nilai dari data didalam Redis. Hampir semua perintah Redis membutuhkan setidaknya sebuah parameter key.

Yang perlu diketahui dari key pada Redis:

1. Penamaan key harus unik.
2. Key pada Redis bersifat binary safe, yang artinya binary sequence apapun dapat dijadikan key. Mulai dari string "foo", bilangan bulat seperti 42, atau bilangan desimal seperti 3.1415, atau binary value seperti 0xff juga bisa dijadikan key.
3. Ukuran maksimal key adalah 512MB. Tapi tidak disarankan membuat key terlalu panjang.
4. Key bersifat case-sensitive. Artinya "foobar" berbeda dengan "fooBar".

Selanjutnya untuk penamaan key, biasanya ada 2 opsi yang sering diperdebatkan, mau yang singkat seperti "inv:id" atau yang mudah dibaca seperti "invoice:id". Semua kembali kepada developer sendiri mau pakai yang singkat atau yang mudah dibaca.

Untuk struktur penamaan key, umumnya adalah seperti contoh dibawah ini:

Misalkan kita mau menampung data followers dari user dengan ID 123.
Key yang dapat kita gunakan adalah:

```
user:123:followers
```

Dimana:

* `user`: nama objek
* `123`: ID user
* `followers`: objek yang ditampung

Tetapi kembali lagi kepada developer mau menggunakan struktur seperti apa yang sesuai dengan kebutuhan. Hanya saja harus konsisten.

Untuk mendefinisikan sebuah nilai dari key menggunakan Redis CLI, cara paling sederhana adalah dengan menggunakan perintah `SET`. Seperti dibawah ini:

```
SET user:123:name "Muhammad Syifa" 
```

Sedangkan untuk mengambil data dari `user:123:name`, gunakan perintah `GET`:

```
GET user:123:name
```

Output:

```
"Muhammad Syifa"
```

###### KEYS vs SCAN

Untuk melihat ada key apa saja yang terdapat dalam database Redis, kita dapat menggunakan perintah `KEYS` atau `SCAN`.

Berikut adalah perbedaan dari ke-2nya:

* `KEYS` memblok transaksi sampai semua key didapat. `SCAN` membaca key satu per satu menggunakan kursor.
* Karena memblok transaksi, `KEYS` tidak disarankan untuk digunakan pada production. Untuk production gunakan `SCAN`.

Contoh penggunaan `KEYS` untuk melihat key yang diawali `user:1`:

```
KEYS user:1*
```

Output:

```bash
1) user:1
2) user:10
3) user:11
4) user:1:followers
...
```

Sedangkan untuk penggunaan `SCAN` untuk hal yang sama adalah sebagai berikut:

```
SCAN 0 MATCH user:1*
```

Output:

```bash
1) "15488" # ini adalah kursor selanjutnya
2) (empty list or set) # ini adalah hasilnya
```

Loh? kok hasilnya kosong? Jadi perintah `SCAN` scan diatas kalau diterjemahkan itu: scan keys mulai dari kursor 0 yang diawali dengan "user:1". Sedangkan secara default perintah SCAN hanya akan membaca 10 key pertama (COUNT = 10). Jadi perintah diatas hanya akan scan 10 key mulai dari kursor 0, dan kalau di kursor tersebut tidak ada yang match dengan "user:1*", hasilnya empty list or set.

Jadi untuk mendapatkan hasilnya, opsinya ada 2, yaitu, melanjutkan iterasi mulai dari kursror "15488", atau menambahkan COUNT.

1. Melanjutkan iterasi:

Kalau mau melanjutkan iterasi, tinggal diubah aja parameter pertamanya jadi:

```
SCAN 15488 MATCH user:1*
```

Nanti dia akan ambil kursor 15488 sampai dengan 10 kursor berikutnya.
Iterasi dianggap selesai jika output dari kursor adalah "0".

2. Menambahkan COUNT

Untuk menambahkan COUNT, caranya:

```
SCAN 0 MATCH user:1* COUNT 1000000
```

Dengan begitu akan dilakukan scanning key sebanyak 1 juta kursor dimulai dari kursor 0. Kalau output kursor selanjutnya belum "0", artinya masih ada key yang belum di scan.

Berikut contoh output kalau ada key yang match:

```bash
1) "0" # kursor selanjutnya, 0 = selesai
2) 1) "user:1"
   2) "user:10"
   3) "user:11"
   4) "user:1:followers"
```

###### DEL vs UNLINK

Berikutnya untuk menghapus key ada 2 perintah yang dapat digunakan.
Yaitu `DEL` dan `UNLINK`. Perbedaannya jika menggunakan `DEL` key dan nilai akan langsung terhapus (synchronous), dengan `UNLINK` keynya dihapus, tetapi nilai dari key tersebut akan dihapus setelahnya (asynchronous).

###### Mengecek Key Exists

Untuk mengecek key ada atau tidaknya kita dapat menggunakan perintah `EXISTS`. Contoh:

```
EXISTS user:1:name
```

Output:

```
"1"
```

1 artinya ada, sedangkan 0 artinya tidak ada.

###### Argumen NX|XX

Saat menggunakan perintah `SET`, kita dapat memberikan argumen NX atau XX. NX berarti "non-exists" yang kalau kita gunakan, akan mencegah Redis untuk meniban nilai yang sebelumnya sudah pernah kita set. Sedangkan XX digunakan jika kita ingin **mengubah** suatu nilai, dengan kata lain jika kita belum punya key tertentu, dan kita gunakan XX, nilai itu tidak akan dibuat.

Contoh:

```bash
SET user:1:name "Muhammad Syifa" NX
OK # set berhasil
SET user:1:name "John Doe" NX
(nil) # set ditolak
GET user:1:name
"Muhammad Syifa" # nilai tidak berubah

SET foo "foobar" XX
GET foo
(nil) # foo tidak diset karena kita belum set foo sebelumnya

SET foo "foobar"
GET foo
"foobar"

SET foo "baz" XX
GET foo
"baz" # nilai berubah karena foo sudah kita set sebelumnya
```

###### Key Expiration

Setiap key pada redis dapat diset waktu expirednya. Dan waktu expirednya juga dapat diubah, ataupun dihapus.
Beberapa perintah untuk mengatur waktu expired dari key adalah sebagai berikut:

* `EXPIRE foo 123`: set waktu expired key foo selama 123 detik.
* `EXPIREAT foo 1568524142`: set waktu expired key foo pada 2019-09-15 05:09:02.
* `PEXPIRE foo 500`: set waktu expired key foo selama 500ms (1/2 detik).
* `PEXPIREAT foo 1568524142500`: set waktu expired key foo pada 2019-09-15 05:09:02:500.
* `TTL foo`: melihat sisa waktu foo menuju expired (dalam detik).
* `PTTL foo`: melihat sisa waktu foo menuju expired (dalam mili-detik).
* `PERSIST foo`: menghapus waktu expired dari key foo.


#### 2. String

Pada Redis, string adalah tipe data yang paling sederhana.
Namun tidak seperti DBMS pada umumnya, Redis tidak hanya memperlakukan string sebagai teks saja. Redis tetap dapat mengenali
apakah string tersebut bersifat numerik, sehingga kita bisa melakukan operasi matematika sederhana disana.

Beberapa hal yang perlu diketahui tentang String di Redis:

1. String digunakan untuk menampung teks.
2. Bilangan bulat atau bilangan desimal.
3. Data biner.
4. Maksimum daya tampung teksnya sebesar 512MB.

Dibawah ini adalah contoh penggunaan string pada Redis (pahami sendiri):

```bash
SET mystr 123
GET mystr
"123" # walaupun diatas kita menulis tanpa kutip, dia akan menjadi string di Redis

DECRBY mystr 1 # kurangi mystr 1
GET mystr
"122"

INCRBY mystr 10 # tambah mystr 10
GET mystr
"132"

SET mystr "foo"
GET mystr
"foo"
INCRBY mystr 10
(error) ERR value is not an integer or out of range

# mengecek encoding dari string
object encoding mystr
"embstr"

SET mystr 10
object encoding mystr
"int"

SET mystr 1.25
object encoding mystr
"embstr" # angka desimal dianggap string
```

#### 3. Hashes

Hash adalah tipe data yang dapat menampung beberapa nilai sekaligus.
Pada bahasa pemrograman lain mungkin kamu mengenalnya dengan sebutan HashMap (Java), JSON, array assoc (PHP), dsb.

Hash pada Redis biasanya digunakan untuk rate limiting atau session cache.

Hash pada Redis memiliki sifat sebagai berikut:

1. Single Level. Tidak seperti JSON yang dapat digunakan untuk menampung nilai sedalam apapun, Hash pada Redis hanya dapat memiliki single level saja.
2. Dapat digunakan perintah ke setiap field seperti `INCRBY`.
3. Kita dapat menghapus atau menambahkan field kedalam Hash.
4. Hash dirancang khusus seefisien mungkin oleh Redis sehingga kamu tidak perlu khawatir kalau mau simpan Hash dengan field yang bejibun.

Untuk menyimpan hash, perintah yang digunakan adalah `HSET`. Contoh untuk menyimpan JSON sebagai berikut:

```json
{
    "name": "Muhammad Syifa",
    "email": "emsifa@gmail.com"
}
```

Perintah `HSET` yang digunakan adalah sebagai berikut:

```
HSET user name "Muhammad Syifa" email "emsifa@gmail.com"
```

Dan berikut adalah perintah-perintah hash yang dapat digunakan (pahami sendiri).

```bash
HSET user name "Muhammad Syifa" email "emsifa@gmail.com"
(2) # 2 artinya kita menyimpan 2 field
HEXISTS user name
(1) # artinya ada
HEXISTS user phone
(0) # artinya ga ada

HGET user name
"Muhammad Syifa"
HGET user phone
(nil)

HGETALL user
1) "name"
2) "Muhammad Syifa"
3) "email"
4) "emsifa@gmail.com"

HDEL user name
HGET user name
(nil)

HSET user age 18
HINCRBY user age 1
HGET user age
"19"

HSETNX user email "foobar@mail.com"
(nil)
HGET user email "emsifa@gmail.com"

```

#### 4. Lists

List pada Redis adalah tipe data yang berisi **sekumpulan string yang berurutan**. Pada bahasa pemrograman lain kamu mengenalnya sebagai array.

Berikut ini poin-poin penting dari tipe data list pada Redis:

1. List berisi sekumpulan string yang berurutan.
2. Nilai setiap item di list boleh sama.
3. Item dapat ditambahkan di awal dan di akhir dari list.
4. List umumnya diterapkan untuk stacks (tumpukan) atau queues (antrian).
5. List tidak dapat nested.
6. Diimplementasikan menggunakan linked list.

Berikut contoh-contoh penerapan list pada Redis (pahami sendiri):

```bash
# set/add item to list
LPUSH mylist 1 2 3 4 5
# get all items in list
LRANGE mylist 0 -1
1) "5" # << LEFT (HEAD)
2) "4"
3) "3"
4) "2"
5) "1" # << RIGHT (TAIL)
# urutan menurun karena yang digunakan adalah LPUSH (LEFT PUSH)

# get items count in list
LLEN mylist
(integer) 5

# get first 3 items in list
LRANGE mylist 0 2
1) "5"
2) "4"
3) "3"

# get last 3 items in list
LRANGE mylist -3 -1
1) "3"
2) "2"
3) "1"

RPUSH mylist foo bar baz
LRANGE mylist 0 -1
1) "5" # << LEFT (HEAD)
2) "4"
3) "3"
4) "2"
5) "1"
6) "foo"
7) "bar"
8) "baz" # << RIGHT (TAIL)

LPOP mylist
"5"
RPOP mylist
"baz"

LRANGE mylist 0 -1
1) "4" # << HEAD
2) "3"
3) "2"
4) "1"
5) "foo"
6) "bar" # << TAIL
```

Dokumentasi selengkapnya tentang list dapat dilihat [disini](https://redis.io/commands#list).

#### 5. Sets

Set adalah tipe data yang berisi sekumpulan string **unik** yang **tidak berurutan**. 

Poin-poin pada tipe data Set antara lain:

1. Set berisi kumpulan string unik, tidak seperti list yang boleh sama.
2. Set tidak berurutan, lagi-lagi tidak seperti list.
3. Set dapat diterapkan operasi untuk mencari perbedaan (difference), persamaan (intersect), atau gabungan (union) dari 2 buah set atau lebih.
4. Set tidak nested.
5. Tipe data set cocok digunakan untuk tag cloud, unique visitor, dsb.

Dibawah ini adalah beberapa operasi set yang penting untuk diketahui:

```bash
# set sebuah 'set' *hah?
SADD cities jakarta bandung bandung
(2) # walaupun set 3, yang tersimpan cuma 2 karena bandung duplikat
SMEMBERS cities
1) "jakarta"
2) "bandung"

# mengecek string ada/tidak didalam sebuah set
SISMEMBER cities jakarta
(1) # ada
SISMEMBER cities hulululu
(0) # tidak ada

# nambahin item baru kedalam set
SADD cities jogja
(1) # 1 item ditambahkan
SMEMBERS cities
1) "jakarta"
2) "bandung"
3) "jogja"

SREM cities jogja
(1) # 1 item terhapus
SMEMBERS cities
1) "jakarta"
2) "bandung"

# hapus random item dari set
SPOP cities
SMEMBERS cities
1) "bandung"

# UNION, INTERSECT, DIFF

SADD myset1 a b c d e
SADD myset2 c d e f g

SDIFF myset1 myset2
1) "b"
2) "a"

SDIFF myset2 myset1
1) "g"
2) "f"

SINTER myset1 myset2
1) "e"
2) "d"
3) "c"

SINTER myset2 myset1 # sama aja
1) "e"
2) "d"
3) "c"

SUNION myset1 myset2
1) "a"
2) "b"
3) "c"
4) "d"
5) "e"
6) "f"
7) "g"
```

#### 6. Sorted Sets

Sorted Set ini seperti set, berisi berisi sekumpulan string yang unik. Hanya saja dia berurutan. Bedanya dengan list, adalah pada sorted set kita mendefinisikan skor pada masing-masing item.

Berikut adalah perintah-perintah yang penting diketahui untuk sorted set.

```bash
# set 'sorted set'
ZADD tinggibadan 160 "A" 155 "B"
# get all items in sorted set (ascending)
ZRANGE tinggibadan 0 -1
1) "B"
2) "A"
# get all items in sorted set (descending)
ZREVRANGE tinggibadan 0 -1
1) "A"
2) "B"

# get all items in sorted set including their scores
ZRANGE tinggibadan 0 -1 WITHSCORES
1) "B"
2) "155"
3) "A"
4) "160"

# get score from an item
ZSCORE tinggibadan "A"
"160"
ZSCORE tinggibadan "Z"
(nil)

# get index from an item
ZRANK tinggibadan A
(1) # index ke-2
ZRANK tinggibadan B
(0) # index pertama

# get count from score range
ZSCORE tinggibadan 160 170
(1) # si A

# get items by score range
ZRANGEBYSCORE tinggibadan 160 170
1) "A"
```

Dokumentasi selengkapnya tentang sorted set bisa dilihat [disini](https://redis.io/commands#sorted_set).

---

Ya, kurang lebih seperti itulah yang saya pelajari pada minggu pertama di kelas RU101 ini.
Untuk catatan kelas lain dan minggu selanjutnya akan saya bahas juga pada tulisan lain. 
